# %% init
%load_ext autoreload
%autoreload 2
%gui qt

from pyHegel.commands import *
_init_pyHegel_globals()

import numpy as np
from scipy.ndimage import gaussian_filter1d

LAB_SCRIPT_PATH = "/home/local/USHERBROOKE/mora0502/Codes/Lab-Scripts" # ABSOLUTE PATH, without trailing /
LAB_SCRIPT_PATH = "C:\Codes\Lab-Scripts" # ABSOLUTE PATH, without trailing /


%cd $LAB_SCRIPT_PATH/Spin/
LOG_PATH = LAB_SCRIPT_PATH + "/Spin/logs"
from MyUtils import *
from Pulses.Builder import *
from Videomode.VideoModeWindow import VideoModeWindow, SweepAxis

# %% setup

awg = instruments.tektronix.tektronix_AWG('USB0::0x0699::0x0503::B030793::0')
gain = awg.gain = 1/(0.02512)*0.4
awg_sr = 40e4
awg.write('SOURce1:RMODe TRIGgered'); awg.write('SOURce1:TINPut BTrigger') 
awg.write('SOURce2:RMODe TRIGgered'); awg.write('SOURce2:TINPut BTrigger') 
awg.write('SOURce3:RMODe TRIGgered'); awg.write('SOURce3:TINPut BTrigger')
awg.write('SOURce1:DAC:RESolution 15') # 15 bits + 1 marker
awg.write('SOURce2:DAC:RESolution 15') 
awg.write('SOURce3:DAC:RESolution 15') 
# debug: awg.clear()

ats = instruments.ATSBoard(systemId=1, cardId=1)
ats.conf = lambda: {'sr':ats.sample_rate.get(), 'pts':ats.samples_per_record.get(), 't':ats.acquisition_length_sec.get()}
ats.active_channels.set(['A','B'])
ats.sample_rate.set(100000)
ats.trigger_level_1.set(1000)
ats.ConfigureBoard()
ats.nbwindows.set(1)
ats.trigger_delay.set(0)

bi7 = instruments.iTest_be214x("TCPIP::192.168.150.112::5025::SOCKET", slot=7)
ST = instruments.LimitDevice((bi7.ramp, {'ch': 1}), min=-4.0, max=4.0)

zi = instruments.zurich_UHF("dev2949")
zi_get = lambda: commands.get((zi.readval, {'vals': ['r'], 'ch': 0}))[0]

rhP1 = bi3 = instruments.iTest_be2102("TCPIP::192.168.150.112::5025::SOCKET", slot=3)
rhP2 = bi1 = instruments.iTest_be2102("TCPIP::192.168.150.112::5025::SOCKET", slot=1)

# %% set a dev_y, then acq while ramping dev_x
awg_sr = 40e4

valueP1, deltaP1, timeP1 = 1.06, 0.040, 0.02
valueP2, deltaP2, nbP2 = 0.609, 0.06, 51

sync_time_after_ramp = 0.015
ramp_direction = 'up' # 'up' or 'down'

# ramp
listP2 = np.linspace(valueP2-deltaP2, valueP2+deltaP2, nbP2)
pulseP1 = Pulse(Segment(duration=timeP1), 
                Segment(duration=timeP1, 
                        waveform=Ramp({'up':-1, 'down':+1}[ramp_direction]*deltaP1, 
                                      {'up':+1, 'down':-1}[ramp_direction]*deltaP1), mark=(0, 1)),
                Segment(duration=sync_time_after_ramp), name='P1')
pulseP2 = pulseP1.genMarksOnly(name='P2')
#pulseP1.plot(pulseP2, wide=True)

# setting
sendSeqToAWG(awg, pulseP1, gain, channel=1, run_after=False, awg_sr=awg_sr, round_nbpts_to_mod64='last')
sendSeqToAWG(awg, pulseP2, gain, channel=2, run_after=True, awg_sr=awg_sr, round_nbpts_to_mod64='last')
sendSeqToAWG(awg, pulseP1, gain, channel=3, run_after=True, awg_sr=awg_sr, round_nbpts_to_mod64='last')
ats.acquisition_length_sec.set(timeP1)
rhP1.ramp.set(valueP1)
rhP2.ramp.set(valueP2)

#  "video" mode

sweepP2 = SweepAxis(listP2, fn_next=rhP2.ramp.set, label='P2', enable=True)

def shiftP1(val): rhP1.ramp.set(rhP1.get()+val)
    
def vmget():
    sweepP2.next()
    
    ats.run_and_wait()
    awg.write('TRIGger BTRigger')
    wait(timeP1)
    data = ats.fetch.get()[2]
    if ramp_direction=='down': data = np.flip(data)
    # filter
    data = gaussianLineByLine(data, 2)
    return data


vm = VideoModeWindow(fn_get=vmget, dim=1, ylabel=f"P1 ramp", xsweep=sweepP2, 
                     axes_dict={'y':[valueP1-deltaP1, valueP1+deltaP1]},fn_yshift=shiftP1)


# %% PSB video mode
#   (P1  ,  P2)
R = (0    , 0)
I = (-.035 , -.035 ) 
L = (+.03 , -.001)

tI, tL, tR = 0.004, 0.003, 0.015

read_delta = (0.01, 0.001)
read_level =( 0.675, 0.918 )

tw = 0.03
acq_on = 'read' # 'full' or 'read'

pulseP1 = Pulse(name='P1')
pulseP1.add(duration=tw)
pulseP1.add(duration=tI, offset=I[0], mark=acq_on=='full')
pulseP1.add(duration=tL, offset=L[0], mark=acq_on=='full')
pulseP1.add(duration=tR, waveform=Ramp(+read_delta[0], -read_delta[0]), mark=True)

pulseP2 = Pulse(name='P2')
pulseP2.add(duration=tw)
pulseP2.add(duration=tI, offset=I[1], mark=acq_on=='full')
pulseP2.add(duration=tL, offset=L[1], mark=acq_on=='full')
pulseP2.add(duration=tR, waveform=Ramp(-read_delta[1], +read_delta[1]), mark=True)


compensateAndEqualizeTime(pulseP1, pulseP2, 0.01)
pulseP1.plot(pulseP2, wide='wider', relative_time=True)
acq_time = pulseP1.getMarkDuration(awg_sr)
ats.acquisition_length_sec.set(acq_time)

sendSeqToAWG(awg, pulseP1, gain, channel=1, run_after=False, awg_sr=awg_sr, round_nbpts_to_mod64='last')
sendSeqToAWG(awg, pulseP2, gain, channel=2, run_after=True, awg_sr=awg_sr, round_nbpts_to_mod64='last')
sendSeqToAWG(awg, pulseP1, gain, channel=3, run_after=True, awg_sr=awg_sr, round_nbpts_to_mod64='last')

rhP1.ramp.set(read_level[0])
rhP2.ramp.set(read_level[1])    

#sweepP1 = SweepAxis(np.linspace(0.61, 0.63, 101), fn_next=rhP1.ramp.set, label='P1', enable=False)
sweepP2 = SweepAxis(np.linspace(read_level[1]-0.001, read_level[1]+0.001, 101), fn_next=rhP2.ramp.set, label='P2', 
                    enable=True)
def shiftP1(val): rhP1.ramp.set(rhP1.get()+val)

def vmget():
    sweepP2.next()
    ats.run_and_wait()
    awg.write('TRIGger BTRigger')
    wait(acq_time)
    data = ats.fetch.get()[2]
    #data = np.flip(data) if acq_on == 'read' else data
    # filter
    data = gaussianLineByLine(data, 2)
    return data

vm = VideoModeWindow(fn_get=vmget, dim=1,
                     xlabel=f"time", ysweep=sweepP2, fn_xshift=shiftP1,
                     axes_dict={'x':acq_time},
                     window_size='wide')

# %% get trace X time
rhP1.ramp.set(0.675)
rhP2.ramp.set(0.9186 )

def getonetrace():
    ats.run_and_wait()
    awg.write('TRIGger BTRigger')
    wait(acq_time)
    data = ats.fetch.get()[2]
    #data = np.flip(data)
    # filter
    #data = gaussianLineByLine(data, 2)
    return data

vm = VideoModeWindow(fn_get=getonetrace, dim=1, wrap_at=1000,
                      xlabel=f"time (s)", axes_dict={'x':ats.acquisition_length_sec.get()},
                      pause_after_one=True)
# %%
B1=0.4
traces = np.array(vm.data_buffer[0].T)

im_splitting, bins = histogramOnEachColumns(traces, bins=100, get_bins=True)

imshow(im_splitting, x_axis=acq_time, y_axis=bins,
       title=f"B1={B1}, B2=0.5", x_label='time (s)', cbar=True,
       save=True, path=LOG_PATH, filename=f"transition_B1_{B1}", metadata=dict(traces=traces))

# %% loop

p1_values = np.linspace(0.61, 0.62, 21)
t0 = time.time()
for v in p1_values:
    print('value' + str(v))
    traces = []
    rhP1.ramp.set(v)
    for i in range(1000):
        print(i)
        traces.append(get())
    traces = np.array(traces)

    im_splitting, bins = histogramOnEachColumns(traces, bins=100, get_bins=True)
            

    imshow(traces, x_axis=ats.acquisition_length_sec.get(),
           x_label='time (s)', y_label='iteration', cbar=False,
           save=True, path=LOG_PATH, filename=f"{len(traces)}_traces",
           metadata=dict(P1=rhP1.get(), P2=rhP2.get()))
        
    imshow(im_splitting, x_axis=ats.acquisition_length_sec.get(), y_axis=bins,
           title=f"P1={rhP1.get()}, P2={rhP2.get()}", cbar=False,
           x_label='time (s)', y_label='histogram', 
           save=True, path=LOG_PATH, filename=f"splitting",
           metadata=dict(P1=rhP1.get(), P2=rhP2.get()))
    
t = time.time()-t0
