# %% init
%load_ext autoreload
%autoreload 2
%gui qt

from pyHegel.commands import *
_init_pyHegel_globals()

import numpy as np
from scipy.ndimage import gaussian_filter1d

LAB_SCRIPT_PATH = "/home/local/USHERBROOKE/mora0502/Codes/Lab-Scripts" # ABSOLUTE PATH, without trailing /
LAB_SCRIPT_PATH = "C:\Codes\Lab-Scripts" # ABSOLUTE PATH, without trailing /


%cd $LAB_SCRIPT_PATH/Spin/
LOG_PATH = LAB_SCRIPT_PATH + "/Spin/logs"
from MyUtils import *
from Analyse.analyse import *
from Pulses.Builder import *
from Videomode.VideoModeWindow import VideoModeWindow, SweepAxis

# %% setup

awg = instruments.tektronix.tektronix_AWG('USB0::0x0699::0x0503::B030793::0')
gain = awg.gain = 1/(0.02512)*0.4
awg_sr = 40e4
awg.write('SOURce1:RMODe TRIGgered'); awg.write('SOURce1:TINPut BTrigger') 
awg.write('SOURce2:RMODe TRIGgered'); awg.write('SOURce2:TINPut BTrigger') 
awg.write('SOURce3:RMODe TRIGgered'); awg.write('SOURce3:TINPut BTrigger')
awg.write('SOURce1:DAC:RESolution 15') # 15 bits + 1 marker
awg.write('SOURce2:DAC:RESolution 15') 
awg.write('SOURce3:DAC:RESolution 15') 
# debug: awg.clear()

ats = instruments.ATSBoard(systemId=1, cardId=1)
ats.conf = lambda: {'sr':ats.sample_rate.get(), 'pts':ats.samples_per_record.get(), 't':ats.acquisition_length_sec.get()}
ats.active_channels.set(['A','B'])
ats.sample_rate.set(100000)
ats.trigger_level_1.set(1000)
ats.ConfigureBoard()
ats.nbwindows.set(1)
ats.trigger_delay.set(0)
def acquire(acq_time):
    ats.run_and_wait()
    awg.write('TRIGger BTRigger')
    wait(acq_time)
    data = ats.fetch.get()[2]
    return data

bi7 = instruments.iTest_be214x("TCPIP::192.168.150.112::5025::SOCKET", slot=7)
ST = instruments.LimitDevice((bi7.ramp, {'ch': 1}), min=-4.0, max=4.0)

zi = instruments.zurich_UHF("dev2949")
zi_get = lambda: commands.get((zi.readval, {'vals': ['r'], 'ch': 0}))[0]

rhP1 = bi3 = instruments.iTest_be2102("TCPIP::192.168.150.112::5025::SOCKET", slot=3)
rhP2 = bi1 = instruments.iTest_be2102("TCPIP::192.168.150.112::5025::SOCKET", slot=1)
def shiftP1(val): rhP1.ramp.set(rhP1.get()+val)
def shiftP2(val): rhP2.ramp.set(rhP2.get()+val)

# %% VM RAMP sur P1
awg_sr = 40e4


valueP1, deltaP1, timeP1 = 1.08, 0.023, 0.012
valueP2, deltaP2, nbP2 = 0.620, 0.05, 101

sync_time_after_ramp = 0.015
ramp_direction = 'up' # 'up' or 'down'

# ramp
listP2 = np.linspace(valueP2-deltaP2, valueP2+deltaP2, nbP2)
pulseP1 = Pulse(name='P1', shape_comp=True)
pulseP1.add(timeP1)
pulseP1.add(timeP1, waveform=Ramp({'up':-1, 'down':+1}[ramp_direction]*deltaP1, 
                                  {'up':+1, 'down':-1}[ramp_direction]*deltaP1), mark=True,)
pulseP1.add(sync_time_after_ramp)

pulseP2 = pulseP1.genMarksOnly(name='P2')
#pulseP1.plot(pulseP2, wide=True, no_shape_comp=False)

# setting
sendSeqToAWG(awg, pulseP1, channel=1, run_after=False, awg_sr=awg_sr, round_nbpts_to_mod64='last')
sendSeqToAWG(awg, pulseP2, channel=2, run_after=True, awg_sr=awg_sr, round_nbpts_to_mod64='last')
sendSeqToAWG(awg, pulseP1, channel=3, run_after=True, awg_sr=awg_sr, round_nbpts_to_mod64='last')
ats.acquisition_length_sec.set(timeP1)
rhP1.ramp.set(valueP1)
rhP2.ramp.set(valueP2)

#  "video" mode

sweepP2 = SweepAxis(listP2, fn_next=rhP2.ramp.set, label='P2', enable=True)
    
def vmget():
    sweepP2.next()
    data = acquire(timeP1)
    if ramp_direction=='down': data = np.flip(data)
    data = gaussianLineByLine(data, 2)
    return data


vm = VideoModeWindow(fn_get=vmget, dim=1, ylabel=f"P1 ramp", xsweep=sweepP2, 
                     axes_dict={'y':[valueP1-deltaP1, valueP1+deltaP1]},fn_yshift=shiftP1)


# %% PSB pulse read ramp
#   (P1  ,  P2)
R = (0    , 0)
I = (-.014 , -.014 ) 
L = (-.012 , +.014)
tI, tL, tR = 0.005, 0.004, 0.004
read_delta = (0.001, 0.000)
tw = 0.02
acq_on = 'read' # 'full' or 'read'

pulseP1 = Pulse(name='P1', shape_comp=True)
pulseP1.add(tw)
pulseP1.add(tI, offset=I[0], mark=acq_on=='full')
pulseP1.add(tL, offset=L[0], mark={'full':True, 'read':(0.9, 1)}[acq_on])
pulseP1.add(tR, waveform=Ramp(-read_delta[0], +read_delta[0]), mark=True)

pulseP2 = Pulse(name='P2', shape_comp=True)
pulseP2.add(tw)
pulseP2.add(tI, offset=I[1], mark=acq_on=='full')
pulseP2.add(tL, offset=L[1], mark={'full':True, 'read':(0.9, 1)}[acq_on])
pulseP2.add(tR, waveform=Ramp(+read_delta[1], -read_delta[1]), mark=True)


compensateAndEqualizeTime(pulseP1, pulseP2, 0.01)

pulseP1.plot(pulseP2, wide='wider', relative_time=True, no_shape_comp=False)
genPWLFile(pulseP2, awg_sr, 'psb_pulse.txt')

acq_time = pulseP1.getMarkDuration(awg_sr)
ats.acquisition_length_sec.set(acq_time)

sendSeqToAWG(awg, pulseP1, channel=1, run_after=False, awg_sr=awg_sr, round_nbpts_to_mod64='last')
sendSeqToAWG(awg, pulseP2, channel=2, run_after=True, awg_sr=awg_sr, round_nbpts_to_mod64='last')
sendSeqToAWG(awg, pulseP1, channel=3, run_after=True, awg_sr=awg_sr, round_nbpts_to_mod64='last')


# %% 
# %% PSB vm
read_level =( 1.08, 0.621 )
rhP1.ramp.set(read_level[0])
rhP2.ramp.set(read_level[1])    

# sweep = SweepAxis(np.linspace(read_level[0]-0.004, read_level[0]+0.004, 101), fn_next=rhP1.ramp.set, label='P1', 
                    # enable=True)
sweep = SweepAxis(np.linspace(read_level[1]-0.003, read_level[1]+0.003, 101), fn_next=rhP2.ramp.set, label='P2', 
                    enable=False)

def vmget():
    sweep.next()
    data = acquire(acq_time)
    #data = np.flip(data) if acq_on == 'read' else data
    data = gaussianLineByLine(data, 2)
    return data

vm = VideoModeWindow(fn_get=vmget, dim=1,
                     xlabel=f"P1 ramp", ysweep=sweep,
                     axes_dict={'x':[read_level[0]-read_delta[0], read_level[0]+read_delta[0]]},
                     fn_xshift=shiftP1, window_size='wide')


# %% PSB trace x fois
read_level =( 1.08, 0.621 )
rhP1.ramp.set(read_level[0])
rhP2.ramp.set(read_level[1])  

vm = VideoModeWindow(fn_get=lambda: acquire(acq_time), dim=1, wrap_at=1000,
                      xlabel=f"time (s)", axes_dict={'x':ats.acquisition_length_sec.get()},
                      pause_after_one=True, play=True)
# %% PSB graph splitting

traces = np.array(vm.data_buffer[0].T)

hist, bins = histogramOnEachColumns(traces, bins=100, get_bins=True)
#hist = head(hist, 900)
imshow(hist, x_axis=acq_time, y_axis=bins, x_axis2=[p1_read-read_delta[0], p1_read+read_delta[0]],
       title=f"B1=0.35, B2=0.3", x_label='time (s)', x_label2='P1 ramp', cbar=True,
       save=False, path=LOG_PATH, filename=f"transition_31-40", metadata=dict(traces=traces))

plotColumns(hist, interval=10, x_label='bins', y_label='signal', cbar=True, z_label='time')

# %% PSB pulse read still
#   (P1  ,  P2)
R = (0    , 0)
I = (-.014 , -.014 ) 
L = (-.012 , +.014)
tI, tL, tR = 0.005, 0.004, 0.004
read_delta = (0.001, 0.000)
tw = 0.02
acq_on = 'read' # 'full' or 'read'

pulseP1 = Pulse(name='P1', shape_comp=True)
pulseP1.add(tw)
pulseP1.add(tI, offset=I[0], mark=acq_on=='full')
pulseP1.add(tL, offset=L[0], mark={'full':True, 'read':(0.9, 1)}[acq_on])
pulseP1.add(tR, mark=True)

pulseP2 = Pulse(name='P2', shape_comp=True)
pulseP2.add(tw)
pulseP2.add(tI, offset=I[1], mark=acq_on=='full')
pulseP2.add(tL, offset=L[1], mark={'full':True, 'read':(0.9, 1)}[acq_on])
pulseP2.add(tR, mark=True)


compensateAndEqualizeTime(pulseP1, pulseP2, 0.01)
pulseP1.plot(pulseP2, wide='wider', relative_time=True, no_shape_comp=False)
genPWLFile(pulseP2, awg_sr, 'psb_pulse.txt')
acq_time = pulseP1.getMarkDuration(awg_sr)
ats.acquisition_length_sec.set(acq_time)

sendSeqToAWG(awg, pulseP1, channel=1, run_after=False, awg_sr=awg_sr, round_nbpts_to_mod64='last')
sendSeqToAWG(awg, pulseP2, channel=2, run_after=True, awg_sr=awg_sr, round_nbpts_to_mod64='last')
sendSeqToAWG(awg, pulseP1, channel=3, run_after=True, awg_sr=awg_sr, round_nbpts_to_mod64='last')


# %% PSB trace x fois
read_level =( 1.08, 0.6212 )
rhP1.ramp.set(read_level[0])
rhP2.ramp.set(read_level[1])

vm = VideoModeWindow(fn_get=lambda: acquire(acq_time), dim=1, wrap_at=1000,
                      xlabel=f"time (s)", axes_dict={'x':ats.acquisition_length_sec.get()},
                      pause_after_one=True, play=True, take_focus=False)

# %% sweep p1
p1_list = np.linspace(1.07, 1.09, 11)

for val in p1_list:
    rhP1.ramp.set(val)
    vm = VideoModeWindow(fn_get=lambda: acquire(acq_time), dim=1, wrap_at=2000,
                          xlabel=f"time (s)", axes_dict={'x':ats.acquisition_length_sec.get()},
                          pause_after_one=True, play=True, take_focus=True)
    
    traces = np.array(vm.data_buffer[0].T)
    
    imshow(traces, x_axis=acq_time,
           title=f"P1={val}, B1=0.35, B2=0.3", y_label='count', x_label='time (s)', cbar=True,
           save=True, path=LOG_PATH, filename=f"read_traces_at_p1_{val}", 
           metadata=dict(pulsep1=str(pulseP1), pulsep2=str(pulseP2)))
    
    vm.close()
