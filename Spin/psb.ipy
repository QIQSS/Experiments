# %% init
LAB_SCRIPT_PATH = "/home/local/USHERBROOKE/mora0502/Codes/Lab-Scripts" # ABSOLUTE PATH, without trailing /
LAB_SCRIPT_PATH = "C:\Codes\Lab-Scripts" # ABSOLUTE PATH, without trailing /

get_ipython().run_line_magic('cd', '$LAB_SCRIPT_PATH/Spin/')
LOG_PATH = LAB_SCRIPT_PATH + "/Spin/logs"

import numpy as np
from MyUtils import *
from Analyse.analyse import *
from Analyse.plot import *
from Pulses.Builder import *
from Videomode.VideoModeWindow import VideoModeWindow, SweepAxis
from alive_progress import alive_bar, alive_it
# %% setup

awg = instruments.tektronix.tektronix_AWG('USB0::0x0699::0x0503::B030793::0')
gain = awg.gain = 1/(0.02512)*0.4
awg_sr = 40e4
channel = {'P1':1, 'P2':2}
send = lambda pulse, ch, awg_sr=awg_sr, run_after=False: sendSeqToAWG(awg, pulse, channel=ch, run_after=run_after, awg_sr=awg_sr, round_nbpts_to_mod64='last')
awg.write('SOURce1:RMODe TRIGgered'); awg.write('SOURce1:TINPut BTrigger')
awg.write('SOURce2:RMODe TRIGgered'); awg.write('SOURce2:TINPut BTrigger')
awg.write('SOURce3:RMODe TRIGgered'); awg.write('SOURce3:TINPut BTrigger')
awg.write('SOURce1:DAC:RESolution 15') # 15 bits + 1 marker
awg.write('SOURce2:DAC:RESolution 15')
awg.write('SOURce3:DAC:RESolution 15')
# debug: awg.clear()

ats = instruments.ATSBoard(systemId=1, cardId=1)
ats.conf = lambda: {'sr':ats.sample_rate.get(), 'pts':ats.samples_per_record.get(), 't':ats.acquisition_length_sec.get()}
ats.active_channels.set(['A','B'])
ats.sample_rate.set(100000)
ats.trigger_level_1.set(1000)
ats.ConfigureBoard()
ats.nbwindows.set(1)
ats.trigger_delay.set(0)
def acquire(acq_time):
    ats.run_and_wait()
    awg.write('TRIGger BTRigger')
    wait(acq_time)
    data = ats.fetch.get()[2]
    return data

bi7 = instruments.iTest_be214x("TCPIP::192.168.150.112::5025::SOCKET", slot=7)
ST = instruments.LimitDevice((bi7.ramp, {'ch': 1}), min=-4.0, max=4.0)

#zi = instruments.zurich_UHF("dev2949")
#zi_get = lambda: commands.get((zi.readval, {'vals': ['r'], 'ch': 0}))[0]

rhP1 = bi3 = instruments.iTest_be2102("TCPIP::192.168.150.112::5025::SOCKET", slot=3)
rhP2 = bi1 = instruments.iTest_be2102("TCPIP::192.168.150.112::5025::SOCKET", slot=1)
def shiftP1(val): rhP1.ramp.set(rhP1.get()+val)
def shiftP2(val): rhP2.ramp.set(rhP2.get()+val)
set_function = {'P1': rhP1.ramp.set, 'P2': rhP2.ramp.set}
shift_function = {'P1': shiftP1, 'P2': shiftP2}

# %% VM RAMP

###### settings
ramp_on = 'P1'; step_on = 'P2' # 'P1' | 'P2'

valueRamp, deltaRamp, timeRamp = 1.04, 0.020, 0.010
valueStep, deltaStep, nbStep = 0.55, 0.005, 101

sync_time_after_ramp = 0.01
ramp_direction = 'up' # 'up' | 'down'
################

# pulses
listStep = np.linspace(valueStep-deltaStep, valueStep+deltaStep, nbStep)
pulseRamp = Pulse(name='ramp', shape_comp=True)
pulseRamp.add(timeRamp/2)
pulseRamp.add(timeRamp, waveform=Ramp({'up': -1, 'down': +1}[ramp_direction]*deltaRamp,
                                      {'up': +1, 'down': -1}[ramp_direction]*deltaRamp), mark=True,)
pulseRamp.add(sync_time_after_ramp)

pulseStep = pulseRamp.genMarksOnly(name='step')
# pulseRamp.plot(pulseStep, wide=True, no_shape_comp=False)

# send to awg
send(pulseStep, channel[step_on])  # channel 1 (2) on P1 (P2)
send(pulseRamp, channel[ramp_on])
send(pulseRamp, ch=3, run_after=True)

ats.acquisition_length_sec.set(timeRamp)
#ats.sample_rate.set(100000)
set_function[step_on](valueStep)
set_function[ramp_on](valueRamp)

#  "video" mode

sweep = SweepAxis(
    listStep, fn_next=set_function[step_on], label=step_on, enable=True)


def vmget():
    sweep.next()
    data = acquire(timeRamp)
    if ramp_direction == 'down':
        data = np.flip(data)
    data = gaussian(data, 2)
    return data

vm = VideoModeWindow(fn_get=vmget, dim=1, ylabel=f"{ramp_on} ramp {ramp_direction}", xsweep=sweep,
                     axes_dict={
                         'y': [valueRamp-deltaRamp, valueRamp+deltaRamp]},
                     fn_yshift=shift_function[ramp_on])


# %% PSB pulse
##### settings
#   (P1  ,  P2)
R = (+.015    , -0.000)
L = (0, 0 )
E = (0 , -.004)

# read center
R = (0    , -0.000)
L = (-.015, 0 )
E = (-.015 , -.005)

tR, tL, tE = 0.05, 0.002, 0.002
read_delta = dict(P1=0.000, P2=-0.000)

tw = 0.015
acq_on = 'full' # 'full' | 'read'

# vm
read_level = {'P1': 1.040, 'P2': 0.554}
to_sweep = 'P1'
sweep_delta, sweep_nb = 0.003, 101
x_axis = 'P2'  # 'P1' | 'P2' | 'time'
filt = True # gaussian filter
##############

pulseP1 = Pulse(name='P1', shape_comp=True)
pulseP1.add(tw)
pulseP1.add(tL, offset=L[0], mark=acq_on=='full')
pulseP1.add(tE, offset=E[0], mark=acq_on=='full')
pulseP1.add(tL, offset=L[0], mark={'full':True, 'read':(0.9, 1)}[acq_on])
pulseP1.add(tR, offset=R[0], waveform=Ramp(-read_delta['P1'], +read_delta['P1']), mark=(0, 0.9))

pulseP2 = Pulse(name='P2', shape_comp=True)
pulseP2.add(tw)
pulseP2.add(tL, offset=L[1], mark=acq_on=='full')
pulseP2.add(tE, offset=E[1], mark=acq_on=='full')
pulseP2.add(tL, offset=L[1], mark={'full':True, 'read':(0.9, 1)}[acq_on])
pulseP2.add(tR, offset=R[1], waveform=Ramp(-read_delta['P2'], +read_delta['P2']), mark=(0, 0.9))

#compensateAndEqualizeTime(pulseP1, pulseP2, 0.01)

pulseP1.plot(pulseP2, wide='wider', relative_time=True, no_shape_comp=False)
genPWLFile(pulseP2, awg_sr, 'psb_pulse.txt')

acq_time = pulseP1.getMarkDuration(awg_sr)
ats.acquisition_length_sec.set(acq_time)
#ats.sample_rate.set(1000000)

send(pulseP1, 1)
send(pulseP2, 2)
send(pulseP1, 3, run_after=True)

rhP1.ramp.set(read_level['P1'])
rhP2.ramp.set(read_level['P2'])
# # vm
sweep = SweepAxis(np.linspace(read_level[to_sweep]-sweep_delta, read_level[to_sweep]+sweep_delta, sweep_nb),
                  fn_next=set_function[to_sweep], label=to_sweep, enable=True)

def vmget():
    sweep.next()
    data = acquire(acq_time)
    data = gaussian(data, 2) if filt else data
    return data

vm = VideoModeWindow(fn_get=vmget, dim=1,
                      xlabel=f"{x_axis}", ysweep=sweep,
                      axes_dict={'x': [read_level[x_axis]-abs(read_delta[x_axis]),
                                      read_level[x_axis]+abs(read_delta[x_axis])]
                                if x_axis != 'time' and read_delta[x_axis]!=0 else acq_time},
                      fn_xshift=shiftP1 if x_axis != 'time' else None, window_size='wide')


# %% PSB trace x fois
read_level = {'P1': 1.040, 'P2': 0.554}
rhP1.ramp.set(read_level['P1'])
rhP2.ramp.set(read_level['P2'])

vm = VideoModeWindow(fn_get=lambda: acquire(acq_time), dim=1, wrap_at=2000,
                      xlabel=f"time (s)", axes_dict={'x':ats.acquisition_length_sec.get()},
                      play=True, pause_after_one=True, take_focus=False, show=True)
#%%
traces = np.array(vm.data_buffer[0].T)
imshow(traces, save=True, path=LOG_PATH,
       metadata=dict(pulseP1=str(pulseP1), pulseP2=str(pulseP2)),
       x_axis=acq_time,
       filename=f"readout")

#hist, bins = histogramOnEachColumns(traces, bins=100, get_bins=True)
#imshow(hist, x_axis=acq_time, y_axis=bins,
#       title=f"", x_label='time (s)', x_label2='', cbar=True,
#       save=True, path=LOG_PATH, filename=f"transition_31-40", metadata=dict(traces=traces))

#plotColumns(hist, interval=10, x_label='bins', y_label='signal', cbar=True, z_label='time')

# %% PSB pulse change read position

points = analyse.genTrapezoidSweep(0.550, 0.557, 22, 
                                       1.03, 1.044, 
                                       1.04, 1.054, 11)
#plt.scatter(np.asarray(points)[:,0], np.asarray(points)[:,1], c=[i for i in range(len(points))])

#points
vp1, vp2 =  1.035, 0.551
##### settings
p1_0, p2_0 = 1.0400, 0.554

# read center
R = (0    , -0.000)
L = (-.010, 0 )
E = (-.010 , -.005)

tR, tL, tE = 0.05, 0.0005, 0.0008
newL = lambda p1, p2: np.asarray(L) + (np.asarray((p1_0, p2_0)) - np.asarray((p1, p2)))
newE = lambda p1, p2: np.asarray(E) + (np.asarray((p1_0, p2_0)) - np.asarray((p1, p2)))
L = newL(vp1, vp2)
E = newE(vp1, vp2)

tw = 0.015
acq_on = 'full' # 'full' | 'read'

# vm
read_level = {'P1': vp1, 'P2': vp2}
to_sweep = 'P1'
sweep_delta, sweep_nb = 0.003, 101
x_axis = 'P2'  # 'P1' | 'P2' | 'time'
filt = True # gaussian filter
##############

pulseP1 = Pulse(name='P1', shape_comp=True)
pulseP1.add(tw)
pulseP1.add(tL, offset=L[0], mark=acq_on=='full')
pulseP1.add(tE, offset=E[0], mark=acq_on=='full')
pulseP1.add(tL, offset=L[0], mark={'full':True, 'read':(0.9, 1)}[acq_on])
pulseP1.add(tR, offset=R[0], mark=(0, 0.9))

pulseP2 = Pulse(name='P2', shape_comp=True)
pulseP2.add(tw)
pulseP2.add(tL, offset=L[1], mark=acq_on=='full')
pulseP2.add(tE, offset=E[1], mark=acq_on=='full')
pulseP2.add(tL, offset=L[1], mark={'full':True, 'read':(0.9, 1)}[acq_on])
pulseP2.add(tR, offset=R[1], mark=(0, 0.9))

#compensateAndEqualizeTime(pulseP1, pulseP2, 0.01)

pulseP1.plot(pulseP2, wide='wider', relative_time=True, no_shape_comp=False)
genPWLFile(pulseP2, awg_sr, 'psb_pulse.txt')

acq_time = pulseP1.getMarkDuration(awg_sr)
ats.acquisition_length_sec.set(acq_time)
#ats.sample_rate.set(1000000)

send(pulseP1, 1)
send(pulseP2, 2)
send(pulseP1, 3, run_after=True)

rhP1.ramp.set(read_level['P1'])
rhP2.ramp.set(read_level['P2'])
# # vm
sweep = SweepAxis(np.linspace(read_level[to_sweep]-sweep_delta, read_level[to_sweep]+sweep_delta, sweep_nb),
                  fn_next=set_function[to_sweep], label=to_sweep, enable=False)

def vmget():
    sweep.next()
    data = acquire(acq_time)
    data = gaussian(data, 2) if filt else data
    return data

vm = VideoModeWindow(fn_get=vmget, dim=1,
                      xlabel=f"{x_axis}", ysweep=sweep,
                      axes_dict={'x': [read_level[x_axis]-abs(read_delta[x_axis]),
                                      read_level[x_axis]+abs(read_delta[x_axis])]
                                if x_axis != 'time' and read_delta[x_axis]!=0 else acq_time},
                      fn_xshift=shiftP1 if x_axis != 'time' else None, window_size='wide')


# %% mesure T1
nb_trace = 2000
p1_0, p2_0 = 1.0400, 0.554

pointsz1 = analyse.genTrapezoidSweep(0.550, 0.5515, 11, 
                                   1.03, 1.0375, 
                                   1.0325, 1.04, 18)


delta = np.asarray((0.55, 1.03)) - np.asarray((0.55015, 1.03025))
delta = np.abs(delta)
points = analyse.genTrapezoidSweep(0.550-delta[0], 0.550, 2, 
                                   1.03-delta[1], 1.0375-delta[1], 
                                   1.0325-delta[1], 1.04-delta[1], 18)
plt.scatter(np.asarray(points)[:,0], np.asarray(points)[:,1], c=[i for i in range(len(points))])

for i, (p2, p1) in alive_it(enumerate(points), spinner=None, total=len(points)):
    #if i < 275: continue # !!!! reprise 1
    #if i < 299: continue # !!!! reprise 2
    
    # read center
    R = (0    , -0.000)
    L = (-.015, 0 )
    E = (-.010 , -.005)
    
    tR, tL, tE = 0.05, 0.0005, 0.0008
    newL = lambda p1, p2: np.asarray(L) + (np.asarray((p1_0, p2_0)) - np.asarray((p1, p2)))
    newE = lambda p1, p2: np.asarray(E) + (np.asarray((p1_0, p2_0)) - np.asarray((p1, p2)))
    L = newL(p1, p2)
    E = newE(p1, p2)
    
    tw = 0.015
    acq_on = 'full' # 'full' | 'read'
    ##############
    
    pulseP1 = Pulse(name='P1', shape_comp=True)
    pulseP1.add(tw)
    pulseP1.add(tL, offset=L[0], mark=acq_on=='full')
    pulseP1.add(tE, offset=E[0], mark=acq_on=='full')
    pulseP1.add(tL, offset=L[0], mark={'full':True, 'read':(0.9, 1)}[acq_on])
    pulseP1.add(tR, offset=R[0], mark=(0, 0.9))
    
    pulseP2 = Pulse(name='P2', shape_comp=True)
    pulseP2.add(tw)
    pulseP2.add(tL, offset=L[1], mark=acq_on=='full')
    pulseP2.add(tE, offset=E[1], mark=acq_on=='full')
    pulseP2.add(tL, offset=L[1], mark={'full':True, 'read':(0.9, 1)}[acq_on])
    pulseP2.add(tR, offset=R[1], mark=(0, 0.9))
    
    acq_time = pulseP1.getMarkDuration(awg_sr)
    ats.acquisition_length_sec.set(acq_time)
    #ats.sample_rate.set(1000000)
    
    awg_overrange = False
    awg_overrange = send(pulseP1, 1) or awg_overrange
    awg_overrange = send(pulseP2, 2) or awg_overrange
    awg_overrange = send(pulseP1, 3, run_after=True) or awg_overrange

    rhP1.ramp.set(p1)
    rhP2.ramp.set(p2)


    vm = VideoModeWindow(fn_get=lambda: acquire(acq_time), dim=1, wrap_at=nb_trace,
                          xlabel=f"time (s), point p1:{p1} p2:{p2}", axes_dict={'x':acq_time},
                          play=True, pause_after_one=True, take_focus=True, show=True)
    
    traces = np.array(vm.data_buffer[0].T)

    imshow(traces, save=True, path=LOG_PATH, show=False,
           metadata=dict(pulseP1=str(pulseP1), pulseP2=str(pulseP2), p1=p1, p2=p2, awg_overrange=awg_overrange),
           filename=f"mesureT1_we_{i}", x_axis=acq_time,
           y_label='count', x_label='time (s)', cbar=False)
        
    wait(1)
    vm.close()
    wait(1)