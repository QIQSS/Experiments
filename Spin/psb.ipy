# %% init
import numpy as np
from matplotlib import pyplot as plt

LAB_SCRIPT_PATH = "/home/local/USHERBROOKE/mora0502/Codes/Lab-Scripts" # ABSOLUTE PATH, without trailing /
LAB_SCRIPT_PATH = "C:\Codes\Lab-Scripts" # ABSOLUTE PATH, without trailing /

get_ipython().run_line_magic('cd', '$LAB_SCRIPT_PATH')
from Pulses.Builder import Pulse
from Pulses.Shapes import Ramp

from Utils import analyse as al
from Utils import instruments as instr
from Utils import plot as pl

from Videomode import VideoModeWindow, SweepAxis

LOG_PATH = LAB_SCRIPT_PATH + "/Logs"

# %% instruement setup
from pyHegel import instruments
awg = instruments.tektronix.tektronix_AWG('USB0::0x0699::0x0503::B030793::0')
gain = awg.gain = 1/(0.02512)*0.4
awg_sr = 40e4
channel = {'P1':1, 'P2':2}
send = lambda pulse, ch, awg_sr=awg_sr, run_after=False: instr.sendSeqToAWG(awg, pulse, channel=ch, run_after=run_after, awg_sr=awg_sr, round_nbpts_to_mod64='last')
awg.write('SOURce1:RMODe TRIGgered'); awg.write('SOURce1:TINPut BTrigger')
awg.write('SOURce2:RMODe TRIGgered'); awg.write('SOURce2:TINPut BTrigger')
awg.write('SOURce3:RMODe TRIGgered'); awg.write('SOURce3:TINPut BTrigger')
awg.write('SOURce1:DAC:RESolution 15') # 15 bits + 1 marker
awg.write('SOURce2:DAC:RESolution 15')
awg.write('SOURce3:DAC:RESolution 15')
# debug: awg.clear()

ats = instruments.ATSBoard(systemId=1, cardId=1)
ats.conf = lambda: {'sr':ats.sample_rate.get(), 'pts':ats.samples_per_record.get(), 't':ats.acquisition_length_sec.get()}
ats.active_channels.set(['A','B'])
ats.sample_rate.set(100000)
ats.trigger_level_1.set(1000)
ats.ConfigureBoard()
ats.nbwindows.set(1)
ats.trigger_delay.set(0)
def fn_acquire(acq_time, sweep=None, fn_filter=None):
    def acq():
        if sweep: sweep.next()
        ats.run_and_wait()
        awg.write('TRIGger BTRigger')
        wait(acq_time)
        data = ats.fetch.get()[2]
        data = fn_filter(data) if fn_filter else data
        return data
    return acq

bi7 = instruments.iTest_be214x("TCPIP::192.168.150.112::5025::SOCKET", slot=7)
ST = instruments.LimitDevice((bi7.ramp, {'ch': 1}), min=-4.0, max=4.0)

#zi = instruments.zurich_UHF("dev2949")
#zi_get = lambda: commands.get((zi.readval, {'vals': ['r'], 'ch': 0}))[0]

rhP1 = bi3 = instruments.iTest_be2102("TCPIP::192.168.150.112::5025::SOCKET", slot=3)
rhP2 = bi1 = instruments.iTest_be2102("TCPIP::192.168.150.112::5025::SOCKET", slot=1)
def shiftP1(val): rhP1.ramp.set(rhP1.get()+val)
def shiftP2(val): rhP2.ramp.set(rhP2.get()+val)
set_function = {'P1': rhP1.ramp.set, 'P2': rhP2.ramp.set}
shift_function = {'P1': shiftP1, 'P2': shiftP2}

# %% VM RAMP

###### settings
ramp_on = 'P2'; step_on = 'P1' # 'P1' | 'P2'

valueRamp, deltaRamp, timeRamp = 0.546, 0.024, 0.030
valueStep, deltaStep, nbStep = 1.028, 0.05, 101

sync_time_after_ramp = 0.015
ramp_direction = 'up' # 'up' | 'down'
######

# pulses
listStep = np.linspace(valueStep-deltaStep, valueStep+deltaStep, nbStep)
pulseRamp = Pulse(name='ramp', shape_comp=True)
pulseRamp.add(timeRamp)
pulseRamp.add(timeRamp, waveform=Ramp({'up': -1, 'down': +1}[ramp_direction]*deltaRamp,
                                      {'up': +1, 'down': -1}[ramp_direction]*deltaRamp), mark=True,)
pulseRamp.add(sync_time_after_ramp)

pulseStep = pulseRamp.genMarksOnly(name='step')
# pulseRamp.plot(pulseStep, wide=True, no_shape_comp=False)

# send to awg
send(pulseStep, channel[step_on])  # channel 1 (2) on P1 (P2)
send(pulseRamp, channel[ramp_on])
send(pulseRamp, ch=3, run_after=True)

ats.acquisition_length_sec.set(timeRamp)
set_function[step_on](valueStep)
set_function[ramp_on](valueRamp)

#  "video" mode

sweep = SweepAxis(listStep, fn_next=set_function[step_on], label=step_on)

vm = VideoModeWindow(fn_get=fn_acquire(timeRamp, sweep,
                     lambda data: al.gaussian(al.flip(data, enabel=ramp_direction == 'down'), 2)),
                     dim=1, ylabel=f"{ramp_on} ramp", xsweep=sweep,
                     axes_dict={
                         'y': [valueRamp-deltaRamp, valueRamp+deltaRamp]},
                     fn_yshift=shift_function[ramp_on])


# %% PSB pulse read ramp
#   (P1  ,  P2)
R = (0    , 0)
I = (-.014 , -.014 )
L = (-.012 , +.014)
tI, tL, tR = 0.005, 0.0005, 0.004
read_delta = dict(P1=0.001, P2=0.000)
tw = 0.015
acq_on = 'full' # 'full' or 'read'

pulseP1 = Pulse(name='P1', shape_comp=True)
pulseP1.add(tw)
pulseP1.add(tI, offset=I[0], mark=acq_on=='full')
pulseP1.add(tL, offset=L[0], mark={'full':True, 'read':(0.9, 1)}[acq_on])
pulseP1.add(tR, waveform=Ramp(-read_delta['P1'], +read_delta['P1']), mark=True)
#pulseP1.add(tR, mark=True) # no ramp

pulseP2 = Pulse(name='P2', shape_comp=True)
pulseP2.add(tw)
pulseP2.add(tI, offset=I[1], mark=acq_on=='full')
pulseP2.add(tL, offset=L[1], mark={'full':True, 'read':(0.9, 1)}[acq_on])
pulseP2.add(tR, waveform=Ramp(+read_delta['P2'], -read_delta['P2']), mark=True)
#pulseP2.add(tR, mark=True) # no ramp

pulseP1.compensateAndEqualizeTime(pulseP2, 0.01)

pulseP1.plot(pulseP2, wide='wider', relative_time=True, no_shape_comp=False)
pulseP2.genPWLFile(awg_sr, 'psb_pulse.txt')

acq_time = pulseP1.getMarkDuration(awg_sr)
ats.acquisition_length_sec.set(acq_time)

send(pulseP1, 1)
send(pulseP2, 2)
send(pulseP1, 3, run_after=True)


# %% PSB vm
# settings
read_level = {'P1': 1.03, 'P2': 0.537}
rhP1.ramp.set(read_level['P1'])
rhP2.ramp.set(read_level['P2'])

to_sweep = 'P2'
x_axis = 'P1'  # 'P1' | 'P2'
sweep = SweepAxis(np.linspace(read_level[to_sweep]-0.003, read_level[to_sweep]+0.003, 101),
                  fn_next=set_function[to_sweep], label=to_sweep, enable=True)
#####

vm = VideoModeWindow(fn_get=fn_acquire(acq_time, sweep), dim=1, 
                     xlabel=f"{x_axis}", ysweep=sweep, 
                     axes_dict={'x': [read_level[x_axis]-read_delta[x_axis], 
                                      read_level[x_axis]+read_delta[x_axis]]}, 
                     fn_xshift=shift_function[x_axis], window_size='wide')


# %% PSB trace x fois
read_level = {'P1': 1.08, 'P2': 0.621}
rhP1.ramp.set(read_level['P1'])
rhP2.ramp.set(read_level['P2'])

vm = VideoModeWindow(fn_get=fn_acquire(acq_time), dim=1, wrap_at=1000,
                      xlabel="time (s)", axes_dict={'x':ats.acquisition_length_sec.get()},
                      pause_after_one=True, play=True)
# %% PSB graph splitting
traces = np.array(vm.data_buffer[0].T)

hist, bins = al.histogramOnEachColumns(traces, bins=100, get_bins=True)

pl.imshow(hist, x_axis=acq_time, y_axis=bins, 
       x_axis2=[read_level['P1']-read_delta['P1'], read_level['P1']+read_delta['P1']],
       title="B1=0.35, B2=0.3", x_label='time (s)', x_label2='P1 ramp', cbar=True,
       save=False, path=LOG_PATH, filename="transition_31-40", metadata=dict(traces=traces))

pl.plotColumns(hist, interval=10, x_label='bins', y_label='signal', cbar=True, z_label='time')




# %% sweep p1
p1_list = np.linspace(1.07, 1.09, 11)

for val in p1_list:
    rhP1.ramp.set(val)
    vm = VideoModeWindow(fn_get=fn_acquire(acq_time), dim=1, wrap_at=2000,
                          xlabel="time (s)", axes_dict={'x':ats.acquisition_length_sec.get()},
                          pause_after_one=True, play=True, take_focus=True)

    traces = np.array(vm.data_buffer[0].T)

    pl.imshow(traces, x_axis=acq_time,
           title=f"P1={val}, B1=0.35, B2=0.3", y_label='count', x_label='time (s)', cbar=True,
           save=True, path=LOG_PATH, filename=f"read_traces_at_p1_{val}",
           metadata=dict(pulsep1=str(pulseP1), pulsep2=str(pulseP2)))

    vm.close()
