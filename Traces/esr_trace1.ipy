# %% imports
# -*- coding: utf-8 -*-
OS = 'w' # 'l' | 'w'
LS_PATH, LOG_PATH = \
            {'w':['C:/Codes/Lab-Scripts', 
                  '//bob.physique.usherbrooke.ca/recherche/Dupont-Ferrier/Projets/IMEC_DD_reflecto/QBB16_SD11b_3/Spin/'],
             'l':['/home/local/USHERBROOKE/mora0502/Codes/Lab-Scripts',
                  '/run/user/1338691803/gvfs/smb-share:server=bob.physique.usherbrooke.ca,share=recherche/Dupont-Ferrier/Projets/IMEC_DD_reflecto/QBB16_SD11b_3/Spin/']}\
            [OS]
%cd $LS_PATH

from Utils import analyse as ua
from Utils import files as uf
from Utils import plot as up
from Utils import utils as uu
from Utils import measure as um

from Utils.plot import imshow, qplot
from tqdm import tqdm
from icecream import ic

from pyHegel import fitting as fit
import numpy as np
from matplotlib import pyplot as plt
import matplotlib

# %% functions

def do_analysis(measure_name, x_lbl='freq', 
                t_acq=0.065, t_read1=[0.02, 0.04], t_read2=[0.045, 0.064],
                skip=[], force=False, save=False, alg='flip'):
    """ 
    find the files then run blockade_probability() for each.
    if save: save the result to the meas file
    if force: try to get the result from the meas file first. if it's good, return this.
    """
    

    
    meas_file, point_files = um.Measure.getFiles(LOG_PATH, measure_name)
    
    meas_npz = uf.loadNpz(meas_file, autosave_on_edit=save)
    meas_npz.metadata['files'] = point_files
    meas_npz['files'] = point_files
    
    if not force and len(meas_npz.array) == len(point_files):
        return meas_npz


    res = []
    slice_read1, slice_read2 = None, None

    if not force:
        point_files = point_files[len(meas_npz.array):]
        res = list(meas_npz.array)
    
    for i, file in tqdm(enumerate(point_files), total=len(point_files)):
        if i < 0: continue
        if i in skip: continue
    
        npz = uf.loadNpz(file, autosave_on_edit=False)

        if i == 0 or not slice_read1:
            timelist = np.linspace(0, t_acq, len(npz.array[0]))
            slice_read1 = slice(ua.findNearest(timelist, t_read1[0], 'id'), ua.findNearest(timelist, t_read1[1], 'id'))
            slice_read2 = slice(ua.findNearest(timelist, t_read2[0], 'id'), ua.findNearest(timelist, t_read2[1], 'id'))

        read1 = npz.array[:,slice_read1]
        read2 = npz.array[:,slice_read2]
        
        if alg != 'flip':
            p_blockade, nb_singlet, nb_triplet = ua.blockade_probability(read1, read2)
        else:
            p_blockade, nb_singlet, nb_triplet = ua.flip_probability(read1, read2)
        res.append([npz.rget(x_lbl), p_blockade, nb_singlet, nb_triplet])

    res = np.array(res)
    
    meas_npz.array = res
        
    return meas_npz
    
def plot(ax, meas_npz, color=0, sigma=2):
    array = meas_npz.array
    sorted_indices = np.argsort(array[:, 0])
    sorted_array = array[sorted_indices]

    sorted_array[::,1] = ua.gaussian(sorted_array[::,1], sigma)

    md = uu.customDict(meas_npz.metadata)
    lbl = f"chirp {md.chirp*1e-6}Mhz, power {md.ampl}dBm"
    lbl += f", drive {md.tdrive*1e3}ms"
    ax.plot(sorted_array[::,0]*1e-9, sorted_array[::,1]*100, label=lbl, marker='o', linestyle='--', color=up.COLORS[color])



# %% loads (measure from before)
nuit3 = uf.loadNpz(LOG_PATH+"results/nuit3.npz")

# %% analyses
freqs0 = do_analysis('freqs0', force=False, save=True)
freqs1 = do_analysis('freqs1', force=False, save=True)
freqs2 = do_analysis('freqs2', force=False, save=True)
nuit = do_analysis('nuit', force=False, save=True)
b600m0 = do_analysis('b600m_groschirp', force=True, save=True)
b600m1 = do_analysis('b600m_1', force=False, save=True, t_acq=0.045, t_read1=[0.02, 0.03], t_read2=[0.035, 0.044] )
b600m_long = do_analysis('b600m_long', force=False, save=True, t_acq=0.045, t_read1=[0.02, 0.03], t_read2=[0.035, 0.044], skip=[667] )
b600m_p1 = do_analysis('b600m_power1', force=False, save=True, t_acq=0.045, t_read1=[0.02, 0.03], t_read2=[0.035, 0.044])
b600m_p2 = do_analysis('b600m_power2', force=False, save=True, t_acq=0.045, t_read1=[0.02, 0.03], t_read2=[0.035, 0.044])
b600m_z1 = do_analysis('b600m_zoom1', force=False, save=True, t_acq=0.045, t_read1=[0.02, 0.03], t_read2=[0.035, 0.044])
b600m_z2 = do_analysis('b600m_zoom2', force=False, save=True, t_acq=0.040, t_read1=[0.015, 0.025], t_read2=[0.030, 0.040])
b600m_n1 = do_analysis('b600m_nuit1', force=False, save=True, t_acq=0.040, t_read1=[0.015, 0.025], t_read2=[0.030, 0.040])
b600m_n12 = do_analysis('b600m_nuit1_suite', force=False, save=True, t_acq=0.040, t_read1=[0.015, 0.025], t_read2=[0.030, 0.040])
b591m_0 = do_analysis('b591m_-5', force=False, save=True, t_acq=0.040, t_read1=[0.015, 0.025], t_read2=[0.030, 0.040])
b591m_1 = do_analysis('b591m_-20', force=False, save=True, t_acq=0.040, t_read1=[0.015, 0.025], t_read2=[0.030, 0.040])
b591m_2 = do_analysis('b591m_-20_1', force=False, save=True, t_acq=0.040, t_read1=[0.015, 0.025], t_read2=[0.030, 0.040])
b591m_3 = do_analysis('b591m_-20_2', force=False, save=True, t_acq=0.040, t_read1=[0.015, 0.025], t_read2=[0.030, 0.040])
b591m_4 = do_analysis('b591m_-20_3', force=False, save=True, t_acq=0.040, t_read1=[0.015, 0.025], t_read2=[0.030, 0.040])

# %% nuit
b591m_nuit = do_analysis('b591m_nuit_1', force=False, save=True, t_acq=0.040, t_read1=[0.015, 0.025], t_read2=[0.030, 0.040])

# %% c
b588m_c1 = do_analysis('b588m_c1', force=False, save=True, t_acq=0.040, t_read1=[0.015, 0.025], t_read2=[0.030, 0.040])
b590m_c2 = do_analysis('b590m_c2', force=False, save=True, t_acq=0.040, t_read1=[0.015, 0.025], t_read2=[0.030, 0.040])
b590m_c3 = do_analysis('b590m_c3', force=False, save=True, t_acq=0.040, t_read1=[0.015, 0.025], t_read2=[0.030, 0.040])
b590m_c4 = do_analysis('b590m_c4', force=False, save=True, t_acq=0.040, t_read1=[0.015, 0.025], t_read2=[0.030, 0.040])

# %%
b590m_c5 = do_analysis('rabi_cancel', force=False, save=True, t_acq=0.040, t_read1=[0.015, 0.025], t_read2=[0.030, 0.040])
b590m_80m = do_analysis('b80m2', alg='blockade', force=False, save=True, t_acq=0.0448, t_read1=[0.015, 0.025], t_read2=[0.035, 0.044])

# %%
#b590m_80m_nuit = do_analysis('b80m_nuit', alg='flip', force=False, save=True, t_acq=0.0448, t_read1=[0.015, 0.025], t_read2=[0.035, 0.044],skip=[1])
b10m_ = do_analysis('b10m_', alg='flip', force=False, save=True, t_acq=0.0448, t_read1=[0.015, 0.025], t_read2=[0.035, 0.044])

# %% plot
fig, ax = plt.subplots(figsize=(16,4))

to_plot = [
            # nuit3, freqs0, freqs1, freqs2, nuit, b600m0, b600m1, b600m_long, b600m_p1, b600m_p2,
            # b600m_z1,
            # b600m_z2,
            # b600m_n1,
            # b600m_n12,
            #b591m_0, 
            b591m_1, b591m_2, b591m_3, b591m_4,
            b591m_nuit,
            b588m_c1,
            b590m_c2,
            b590m_c3,
            b590m_c4,
            b590m_c5,
            #b590m_80m ,
            b10m_
           ]
[plot(ax, line, i, sigma=0) for i, line in enumerate(to_plot)]

up.modFig1d(fig, ax)
ax.set_xlabel('frequence (GHz)')
ax.set_ylabel('$P_{flip} (\%)$')
ax.grid()
fig.show()
#uu.mplqt(fig)

# %% rabi

rabi1 = do_analysis('rabi1', force=False, save=True, x_lbl='tdrive', t_acq=0.040, t_read1=[0.015, 0.025], t_read2=[0.030, 0.040])
rabi4 = do_analysis('rabi4', skip=[4,9],force=False, save=True, x_lbl='tdrive', t_acq=0.040, t_read1=[0.015, 0.025], t_read2=[0.030, 0.040])
rabi5 = do_analysis('rabi5', force=False, save=True, x_lbl='tdrive', t_acq=0.040, t_read1=[0.015, 0.025], t_read2=[0.030, 0.040])

## %% plot

fig, ax = plt.subplots(figsize=(16,4))
    
def plot_rabi(ax, meas_npz, color=0, sigma=0):
    array = meas_npz.array
    sorted_indices = np.argsort(array[:, 0])
    sorted_array = array[sorted_indices]

    sorted_array[::,1] = ua.gaussian(sorted_array[::,1], sigma)
    
    md = uu.customDict(meas_npz.metadata)
    lbl = f"freq {md.freq*1e-9}Ghz, power {md.ampl}dBm"
    ax.plot(sorted_array[::,0]*1e6, sorted_array[::,1]*100, label=lbl, marker='o', linestyle='--', color=up.COLORS[color])


to_plot = [rabi1,
           rabi4,
           rabi5,
           ]
[plot_rabi(ax, line, i, 0) for i, line in enumerate(to_plot)]

up.modFig1d(fig, ax)
ax.set_xlabel('$t_{drive}\ (\mu s)$')
ax.set_ylabel('$P_{flip}\ (\%)$')
ax.grid()
fig.show()
#uu.mplqt(fig)
